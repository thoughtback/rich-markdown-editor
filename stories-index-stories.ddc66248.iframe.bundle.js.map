{"version":3,"file":"stories-index-stories.ddc66248.iframe.bundle.js","mappings":";;AA6BA;AACA;AACA;AACA;AAGA;;;;ACwJA;;AAEA;;;;;;;;;;;;;;;;;;AAkBA;;;;;AAKA;;;;;;;;AAQA;;;;;;;;;;;;;;;;;AAwBA;;AChPA;AACA;;;;;;;;;;;AAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACwBA;;;;;ACOA;;;;;AAQA;AACA;AAEA;;;;;;AAMA;AACA;AAGA;;;AAKA;;AAIA;AAGA;;;;;ACkSA;AACA;;;;;;;;;;;;;;;;;;;;;;AAwBA;;;ACxYA;;;;;;ACeA;;;;;;;ACTA;;AC+gBA;;;AAGA;AAGA;;;;;;AAQA;;;AAKA;;;AAGA;;;;;AAOA;AAOA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;;;AAGA;;;;;AAaA;;;;;;;;;;;AC9hBA;AACA;AAIA;;;;;;AAUA;AACA;;AAQA;AACA;;;AAKA;;ACtGA;ACDA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA;;;;;;;;;;;;;AAaA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CA;;;;;;;;;;;;AAYA;AACA;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AACA;AACA;;;AAGA;;;;;;;;;;;;;;;;;;;;;;AAsBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmDA;;;;;;AAMA;;;;;;;;;AASA;;;;;;;;;;;;;;AAcA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CA;;;;;;;;;;AAUA;;;AAGA;;;;;;;;;;;;;AAaA;AACA;;;;;;AAMA;;;;;;;;;;;;;;;;;AAiBA;;;;;;AAMA;AACA;;;AAGA;;;;;AAKA;AACA;;;AAGA;;;;;;;;;;;;;;;;;AAiBA;;;AAGA;;;;;;;;;;AAUA;AACA;;;;;;AAMA;;;;;;;;;;;;;AAcA;;;;;AAKA;;;;;AAKA;AACA;;;;;;;;;;;;;;AAcA;;;;;;;;;;;;;;;;;;;AAmBA;;;;AAIA;;;;;;;;;AASA;;;;;AAKA;;;;;;;;;;;;AAYA;;;;;;;;;;;;;;AAcA;;;;;AAKA;AAEA;AAEA;;;;;;;;;;;;;;;;;;;;AAoBA;;;;;;;;;;;AAWA;;;;;AAKA;AACA;;AAEA;;;;;;AAMA;AACA;;;AAGA;;;;;;;;;;AAUA;AACA;;;;;;;;;;;;;;;;;;;;;AAqBA;;;;;;;;;;AAUA;;;;AAIA;;;;;;;;;;;;;;;;AAgBA;;AAEA;;;AAGA;;;;;;;;;;;;;;AAcA;;;;;;;;;;;;;;;AAeA;;;;AAIA;;;;;;;;;;AAUA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;;;;AAOA;;;;;;;;AAQA;;;;AAIA;;;;;;AAMA;;;;;AAKA;;;;;;;;AAQA;;;;;;;;;;;;;;AAcA;;;;;;;;;;;;;;;;;;;;AAoBA;;;;AAIA;;;;;;;AAOA;;;AAGA;;;;;AAKA;;;;;;;;;;;;;;;;;AAkBA;;;AAGA;AACA;AACA;;;;AAIA;;;AAGA;;;AAGA;;;AAGA;;;;;;;;;AASA;;;;AAIA;AACA;AACA;AACA;;;;AAIA;;;AAGA;;;AAGA;;;AAGA;;;;;;;;AAQA;;;;AAIA;;;AAGA;AACA;;;;AAIA;;;AAGA;;;;;;;;;;;;AAYA;;;;;;;;;AAUA;;;;;;;;;;AAUA;AACA;;;;;;;AAOA;AACA;AACA;AACA;;;;;;;;AAQA;;;;AAIA;;;;;AAKA;;;;;;;;;;;;;AAaA;;;AAGA;;;;;;;;;;AAUA;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;AAuBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA;;;AC7+BA;;;;;;;;ACgcA;AACA;;;;;;;;;;;;;AAaA;;;AAKA;;;;;;AAMA;;;;;;;;;;;;;;;;AAgBA;;;;AAMA;;;;;;AAMA;;;;;AAKA;;;AC/fA","sources":["webpack://@thoughtback/rich-markdown-editor/./src/components/Flex.tsx","webpack://@thoughtback/rich-markdown-editor/./src/components/FloatingToolbar.tsx","webpack://@thoughtback/rich-markdown-editor/./src/components/Input.tsx","webpack://@thoughtback/rich-markdown-editor/./src/components/ToolbarButton.tsx","webpack://@thoughtback/rich-markdown-editor/./src/components/LinkSearchResult.tsx","webpack://@thoughtback/rich-markdown-editor/./src/components/LinkEditor.tsx","webpack://@thoughtback/rich-markdown-editor/./src/components/ToolbarSeparator.tsx","webpack://@thoughtback/rich-markdown-editor/./src/components/ToolbarMenu.tsx","webpack://@thoughtback/rich-markdown-editor/./src/components/VisuallyHidden.tsx","webpack://@thoughtback/rich-markdown-editor/./src/components/CommandMenu.tsx","webpack://@thoughtback/rich-markdown-editor/./src/components/BlockMenuItem.tsx","webpack://@thoughtback/rich-markdown-editor/./src/components/EmojiMenuItem.tsx","webpack://@thoughtback/rich-markdown-editor/./src/styles/editor.ts","webpack://@thoughtback/rich-markdown-editor/./src/lib/Extension.ts","webpack://@thoughtback/rich-markdown-editor/./src/nodes/Image.tsx","webpack://@thoughtback/rich-markdown-editor/./src/queries/getParentListItem.ts"],"sourcesContent":["import * as React from \"react\";\nimport styled from \"styled-components\";\n\ntype JustifyValues =\n  | \"center\"\n  | \"space-around\"\n  | \"space-between\"\n  | \"flex-start\"\n  | \"flex-end\";\n\ntype AlignValues =\n  | \"stretch\"\n  | \"center\"\n  | \"baseline\"\n  | \"flex-start\"\n  | \"flex-end\";\n\ntype Props = {\n  style?: React.CSSProperties;\n  column?: boolean;\n  align?: AlignValues;\n  justify?: JustifyValues;\n  auto?: boolean;\n  className?: string;\n  children?: React.ReactNode;\n};\n\nconst Flex = styled.div<Props>`\n  display: flex;\n  flex: ${({ auto }: Props) => (auto ? \"1 1 auto\" : \"initial\")};\n  flex-direction: ${({ column }: Props) => (column ? \"column\" : \"row\")};\n  align-items: ${({ align }: Props) => align};\n  justify-content: ${({ justify }: Props) => justify};\n`;\n\nexport default Flex;\n","import * as React from \"react\";\nimport { Portal } from \"react-portal\";\nimport { EditorView } from \"prosemirror-view\";\nimport useComponentSize from \"../hooks/useComponentSize\";\nimport useMediaQuery from \"../hooks/useMediaQuery\";\nimport useViewportHeight from \"../hooks/useViewportHeight\";\nimport styled from \"styled-components\";\n\nconst SSR = typeof window === \"undefined\";\n\ntype Props = {\n  active?: boolean;\n  view: EditorView;\n  children: React.ReactNode;\n  forwardedRef?: React.RefObject<HTMLDivElement> | null;\n};\n\nconst defaultPosition = {\n  left: -1000,\n  top: 0,\n  offset: 0,\n  visible: false,\n};\n\nfunction usePosition({ menuRef, isSelectingText, props }) {\n  const { view, active } = props;\n  const { selection } = view.state;\n  const { width: menuWidth, height: menuHeight } = useComponentSize(menuRef);\n  const viewportHeight = useViewportHeight();\n  const isTouchDevice = useMediaQuery(\"(hover: none) and (pointer: coarse)\");\n\n  if (!active || !menuWidth || !menuHeight || SSR || isSelectingText) {\n    return defaultPosition;\n  }\n\n  // If we're on a mobile device then stick the floating toolbar to the bottom\n  // of the screen above the virtual keyboard.\n  if (isTouchDevice && viewportHeight) {\n    return {\n      left: 0,\n      right: 0,\n      top: viewportHeight - menuHeight,\n      offset: 0,\n      visible: true,\n    };\n  }\n\n  // based on the start and end of the selection calculate the position at\n  // the center top\n  let fromPos;\n  let toPos;\n  try {\n    fromPos = view.coordsAtPos(selection.from);\n    toPos = view.coordsAtPos(selection.to, -1);\n  } catch (err) {\n    console.warn(err);\n    return defaultPosition;\n  }\n\n  // ensure that start < end for the menu to be positioned correctly\n  const selectionBounds = {\n    top: Math.min(fromPos.top, toPos.top),\n    bottom: Math.max(fromPos.bottom, toPos.bottom),\n    left: Math.min(fromPos.left, toPos.left),\n    right: Math.max(fromPos.right, toPos.right),\n  };\n\n  // tables are an oddity, and need their own positioning logic\n  const isColSelection = selection.isColSelection && selection.isColSelection();\n  const isRowSelection = selection.isRowSelection && selection.isRowSelection();\n\n  if (isColSelection) {\n    const { node: element } = view.domAtPos(selection.from);\n    const { width } = element.getBoundingClientRect();\n    selectionBounds.top -= 20;\n    selectionBounds.right = selectionBounds.left + width;\n  }\n\n  if (isRowSelection) {\n    selectionBounds.right = selectionBounds.left = selectionBounds.left - 18;\n  }\n\n  const isImageSelection =\n    selection.node && selection.node.type.name === \"image\";\n  // Images need their own positioning to get the toolbar in the center\n  if (isImageSelection) {\n    const element = view.nodeDOM(selection.from);\n\n    // Images are wrapped which impacts positioning - need to traverse through\n    // p > span > div.image\n    const imageElement = element.getElementsByTagName(\"img\")[0];\n    const { left, top, width } = imageElement.getBoundingClientRect();\n\n    return {\n      left: Math.round(left + width / 2 + window.scrollX - menuWidth / 2),\n      top: Math.round(top + window.scrollY - menuHeight),\n      offset: 0,\n      visible: true,\n    };\n  } else {\n    // calcluate the horizontal center of the selection\n    const halfSelection =\n      Math.abs(selectionBounds.right - selectionBounds.left) / 2;\n    const centerOfSelection = selectionBounds.left + halfSelection;\n\n    // position the menu so that it is centered over the selection except in\n    // the cases where it would extend off the edge of the screen. In these\n    // instances leave a margin\n    const margin = 12;\n    const left = Math.min(\n      window.innerWidth - menuWidth - margin,\n      Math.max(margin, centerOfSelection - menuWidth / 2)\n    );\n    const top = Math.min(\n      window.innerHeight - menuHeight - margin,\n      Math.max(margin, selectionBounds.top - menuHeight)\n    );\n\n    // if the menu has been offset to not extend offscreen then we should adjust\n    // the position of the triangle underneath to correctly point to the center\n    // of the selection still\n    const offset = left - (centerOfSelection - menuWidth / 2);\n    return {\n      left: Math.round(left + window.scrollX),\n      top: Math.round(top + window.scrollY),\n      offset: Math.round(offset),\n      visible: true,\n    };\n  }\n}\n\nfunction FloatingToolbar(props) {\n  const menuRef = props.forwardedRef || React.createRef<HTMLDivElement>();\n  const [isSelectingText, setSelectingText] = React.useState(false);\n\n  const position = usePosition({\n    menuRef,\n    isSelectingText,\n    props,\n  });\n\n  React.useEffect(() => {\n    const handleMouseDown = () => {\n      if (!props.active) {\n        setSelectingText(true);\n      }\n    };\n\n    const handleMouseUp = () => {\n      setSelectingText(false);\n    };\n\n    window.addEventListener(\"mousedown\", handleMouseDown);\n    window.addEventListener(\"mouseup\", handleMouseUp);\n\n    return () => {\n      window.removeEventListener(\"mousedown\", handleMouseDown);\n      window.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [props.active]);\n\n  // only render children when state is updated to visible\n  // to prevent gaining input focus before calculatePosition runs\n  return (\n    <Portal>\n      <Wrapper\n        active={props.active && position.visible}\n        ref={menuRef}\n        offset={position.offset}\n        style={{\n          top: `${position.top}px`,\n          left: `${position.left}px`,\n        }}\n      >\n        {position.visible && props.children}\n      </Wrapper>\n    </Portal>\n  );\n}\n\nconst Wrapper = styled.div<{\n  active?: boolean;\n  offset: number;\n}>`\n  will-change: opacity, transform;\n  padding: 8px 16px;\n  position: absolute;\n  z-index: ${(props) => props.theme.zIndex + 100};\n  opacity: 0;\n  background-color: ${(props) => props.theme.toolbarBackground};\n  border-radius: 4px;\n  transform: scale(0.95);\n  transition: opacity 150ms cubic-bezier(0.175, 0.885, 0.32, 1.275),\n    transform 150ms cubic-bezier(0.175, 0.885, 0.32, 1.275);\n  transition-delay: 150ms;\n  line-height: 0;\n  height: 40px;\n  box-sizing: border-box;\n  pointer-events: none;\n  white-space: nowrap;\n\n  &::before {\n    content: \"\";\n    display: block;\n    width: 24px;\n    height: 24px;\n    transform: translateX(-50%) rotate(45deg);\n    background: ${(props) => props.theme.toolbarBackground};\n    border-radius: 3px;\n    z-index: -1;\n    position: absolute;\n    bottom: -2px;\n    left: calc(50% - ${(props) => props.offset || 0}px);\n    pointer-events: none;\n  }\n\n  * {\n    box-sizing: border-box;\n  }\n\n  ${({ active }) =>\n    active &&\n    `\n    transform: translateY(-6px) scale(1);\n    opacity: 1;\n  `};\n\n  @media print {\n    display: none;\n  }\n\n  @media (hover: none) and (pointer: coarse) {\n    &:before {\n      display: none;\n    }\n\n    transition: opacity 150ms cubic-bezier(0.175, 0.885, 0.32, 1.275);\n    transform: scale(1);\n    border-radius: 0;\n    width: 100vw;\n    position: fixed;\n  }\n`;\n\nexport default React.forwardRef(function FloatingToolbarWithForwardedRef(\n  props: Props,\n  ref: React.RefObject<HTMLDivElement>\n) {\n  return <FloatingToolbar {...props} forwardedRef={ref} />;\n});\n","import styled from \"styled-components\";\n\nconst Input = styled.input`\n  font-size: 15px;\n  background: ${(props) => props.theme.toolbarInput};\n  color: ${(props) => props.theme.toolbarItem};\n  border-radius: 2px;\n  padding: 3px 8px;\n  border: 0;\n  margin: 0;\n  outline: none;\n  flex-grow: 1;\n\n  @media (hover: none) and (pointer: coarse) {\n    font-size: 16px;\n  }\n`;\n\nexport default Input;\n","import styled from \"styled-components\";\n\ntype Props = { active?: boolean; disabled?: boolean };\n\nexport default styled.button<Props>`\n  display: inline-block;\n  flex: 0;\n  width: 24px;\n  height: 24px;\n  cursor: pointer;\n  margin-left: 8px;\n  border: none;\n  background: none;\n  transition: opacity 100ms ease-in-out;\n  padding: 0;\n  opacity: 0.7;\n  outline: none;\n  pointer-events: all;\n  position: relative;\n\n  &:first-child {\n    margin-left: 0;\n  }\n\n  &:hover {\n    opacity: 1;\n  }\n\n  &:disabled {\n    opacity: 0.3;\n    cursor: default;\n  }\n\n  &:before {\n    position: absolute;\n    content: \"\";\n    top: -4px;\n    right: -4px;\n    left: -4px;\n    bottom: -4px;\n  }\n\n  ${(props) => props.active && \"opacity: 1;\"};\n`;\n","import * as React from \"react\";\nimport scrollIntoView from \"smooth-scroll-into-view-if-needed\";\nimport styled from \"styled-components\";\n\ntype Props = {\n  onClick: (event: React.MouseEvent) => void;\n  onMouseOver: (event: React.MouseEvent) => void;\n  icon: React.ReactNode;\n  selected: boolean;\n  title: string;\n  subtitle?: string;\n};\n\nfunction LinkSearchResult({ title, subtitle, selected, icon, ...rest }: Props) {\n  const ref = React.useCallback(\n    (node) => {\n      if (selected && node) {\n        scrollIntoView(node, {\n          scrollMode: \"if-needed\",\n          block: \"center\",\n          boundary: (parent) => {\n            // All the parent elements of your target are checked until they\n            // reach the #link-search-results. Prevents body and other parent\n            // elements from being scrolled\n            return parent.id !== \"link-search-results\";\n          },\n        });\n      }\n    },\n    [selected]\n  );\n\n  return (\n    <ListItem ref={ref} compact={!subtitle} selected={selected} {...rest}>\n      <IconWrapper>{icon}</IconWrapper>\n      <div>\n        <Title>{title}</Title>\n        {subtitle ? <Subtitle selected={selected}>{subtitle}</Subtitle> : null}\n      </div>\n    </ListItem>\n  );\n}\n\nconst IconWrapper = styled.span`\n  flex-shrink: 0;\n  margin-right: 4px;\n  opacity: 0.8;\n`;\n\nconst ListItem = styled.li<{\n  selected: boolean;\n  compact: boolean;\n}>`\n  display: flex;\n  align-items: center;\n  padding: 8px;\n  border-radius: 2px;\n  color: ${(props) => props.theme.toolbarItem};\n  background: ${(props) =>\n    props.selected ? props.theme.toolbarHoverBackground : \"transparent\"};\n  font-family: ${(props) => props.theme.fontFamily};\n  text-decoration: none;\n  overflow: hidden;\n  white-space: nowrap;\n  cursor: pointer;\n  user-select: none;\n  line-height: ${(props) => (props.compact ? \"inherit\" : \"1.2\")};\n  height: ${(props) => (props.compact ? \"28px\" : \"auto\")};\n`;\n\nconst Title = styled.div`\n  font-size: 14px;\n  font-weight: 500;\n`;\n\nconst Subtitle = styled.div<{\n  selected: boolean;\n}>`\n  font-size: 13px;\n  opacity: ${(props) => (props.selected ? 0.75 : 0.5)};\n`;\n\nexport default LinkSearchResult;\n","import * as React from \"react\";\nimport { setTextSelection } from \"prosemirror-utils\";\nimport { EditorView } from \"prosemirror-view\";\nimport { Mark } from \"prosemirror-model\";\nimport {\n  DocumentIcon,\n  CloseIcon,\n  PlusIcon,\n  TrashIcon,\n  OpenIcon,\n} from \"outline-icons\";\nimport styled, { withTheme } from \"styled-components\";\nimport isUrl from \"../lib/isUrl\";\nimport theme from \"../styles/theme\";\nimport Flex from \"./Flex\";\nimport Input from \"./Input\";\nimport ToolbarButton from \"./ToolbarButton\";\nimport LinkSearchResult from \"./LinkSearchResult\";\nimport baseDictionary from \"../dictionary\";\n\nexport type SearchResult = {\n  title: string;\n  subtitle?: string;\n  url: string;\n};\n\ntype Props = {\n  mark?: Mark;\n  from: number;\n  to: number;\n  tooltip: typeof React.Component | React.FC<any>;\n  dictionary: typeof baseDictionary;\n  onRemoveLink?: () => void;\n  onCreateLink?: (title: string) => Promise<void>;\n  onSearchLink?: (term: string) => Promise<SearchResult[]>;\n  onSelectLink: (options: {\n    href: string;\n    title?: string;\n    from: number;\n    to: number;\n  }) => void;\n  onClickLink: (href: string, event: MouseEvent) => void;\n  onShowToast?: (message: string, code: string) => void;\n  view: EditorView;\n  theme: typeof theme;\n};\n\ntype State = {\n  results: {\n    [keyword: string]: SearchResult[];\n  };\n  value: string;\n  previousValue: string;\n  selectedIndex: number;\n};\n\nclass LinkEditor extends React.Component<Props, State> {\n  discardInputValue = false;\n  initialValue = this.href;\n  initialSelectionLength = this.props.to - this.props.from;\n\n  state: State = {\n    selectedIndex: -1,\n    value: this.href,\n    previousValue: \"\",\n    results: {},\n  };\n\n  get href(): string {\n    return this.props.mark ? this.props.mark.attrs.href : \"\";\n  }\n\n  get suggestedLinkTitle(): string {\n    const { state } = this.props.view;\n    const { value } = this.state;\n    const selectionText = state.doc.cut(\n      state.selection.from,\n      state.selection.to\n    ).textContent;\n\n    return value.trim() || selectionText.trim();\n  }\n\n  componentWillUnmount = () => {\n    // If we discarded the changes then nothing to do\n    if (this.discardInputValue) {\n      return;\n    }\n\n    // If the link is the same as it was when the editor opened, nothing to do\n    if (this.state.value === this.initialValue) {\n      return;\n    }\n\n    // If the link is totally empty or only spaces then remove the mark\n    const href = (this.state.value || \"\").trim();\n    if (!href) {\n      return this.handleRemoveLink();\n    }\n\n    this.save(href, href);\n  };\n\n  save = (href: string, title?: string): void => {\n    href = href.trim();\n\n    if (href.length === 0) return;\n\n    this.discardInputValue = true;\n    const { from, to } = this.props;\n\n    // Make sure a protocol is added to the beginning of the input if it's\n    // likely an absolute URL that was entered without one.\n    if (\n      !isUrl(href) &&\n      !href.startsWith(\"/\") &&\n      !href.startsWith(\"#\") &&\n      !href.startsWith(\"mailto:\")\n    ) {\n      href = `https://${href}`;\n    }\n\n    this.props.onSelectLink({ href, title, from, to });\n  };\n\n  handleKeyDown = (event: React.KeyboardEvent): void => {\n    switch (event.key) {\n      case \"Enter\": {\n        event.preventDefault();\n        const { selectedIndex, value } = this.state;\n        const results = this.state.results[value] || [];\n        const { onCreateLink } = this.props;\n\n        if (selectedIndex >= 0) {\n          const result = results[selectedIndex];\n          if (result) {\n            this.save(result.url, result.title);\n          } else if (onCreateLink && selectedIndex === results.length) {\n            this.handleCreateLink(this.suggestedLinkTitle);\n          }\n        } else {\n          // saves the raw input as href\n          this.save(value, value);\n        }\n\n        if (this.initialSelectionLength) {\n          this.moveSelectionToEnd();\n        }\n\n        return;\n      }\n\n      case \"Escape\": {\n        event.preventDefault();\n\n        if (this.initialValue) {\n          this.setState({ value: this.initialValue }, this.moveSelectionToEnd);\n        } else {\n          this.handleRemoveLink();\n        }\n        return;\n      }\n\n      case \"ArrowUp\": {\n        if (event.shiftKey) return;\n        event.preventDefault();\n        event.stopPropagation();\n        const prevIndex = this.state.selectedIndex - 1;\n\n        this.setState({\n          selectedIndex: Math.max(-1, prevIndex),\n        });\n        return;\n      }\n\n      case \"ArrowDown\":\n        if (event.shiftKey) return;\n      case \"Tab\": {\n        event.preventDefault();\n        event.stopPropagation();\n        const { selectedIndex, value } = this.state;\n        const results = this.state.results[value] || [];\n        const total = results.length;\n        const nextIndex = selectedIndex + 1;\n\n        this.setState({\n          selectedIndex: Math.min(nextIndex, total),\n        });\n        return;\n      }\n    }\n  };\n\n  handleFocusLink = (selectedIndex: number) => {\n    this.setState({ selectedIndex });\n  };\n\n  handleChange = async (event): Promise<void> => {\n    const value = event.target.value;\n\n    this.setState({\n      value,\n      selectedIndex: -1,\n    });\n\n    const trimmedValue = value.trim();\n\n    if (trimmedValue && this.props.onSearchLink) {\n      try {\n        const results = await this.props.onSearchLink(trimmedValue);\n        this.setState((state) => ({\n          results: {\n            ...state.results,\n            [trimmedValue]: results,\n          },\n          previousValue: trimmedValue,\n        }));\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  };\n\n  handlePaste = (): void => {\n    setTimeout(() => this.save(this.state.value, this.state.value), 0);\n  };\n\n  handleOpenLink = (event): void => {\n    event.preventDefault();\n    this.props.onClickLink(this.href, event);\n  };\n\n  handleCreateLink = (value: string) => {\n    this.discardInputValue = true;\n    const { onCreateLink } = this.props;\n\n    value = value.trim();\n    if (value.length === 0) return;\n\n    if (onCreateLink) return onCreateLink(value);\n  };\n\n  handleRemoveLink = (): void => {\n    this.discardInputValue = true;\n\n    const { from, to, mark, view, onRemoveLink } = this.props;\n    const { state, dispatch } = this.props.view;\n\n    if (mark) {\n      dispatch(state.tr.removeMark(from, to, mark));\n    }\n\n    if (onRemoveLink) {\n      onRemoveLink();\n    }\n\n    view.focus();\n  };\n\n  handleSelectLink = (url: string, title: string) => (event) => {\n    event.preventDefault();\n    this.save(url, title);\n\n    if (this.initialSelectionLength) {\n      this.moveSelectionToEnd();\n    }\n  };\n\n  moveSelectionToEnd = () => {\n    const { to, view } = this.props;\n    const { state, dispatch } = view;\n    dispatch(setTextSelection(to)(state.tr));\n    view.focus();\n  };\n\n  render() {\n    const { dictionary, theme } = this.props;\n    const { value, selectedIndex } = this.state;\n    const results =\n      this.state.results[value.trim()] ||\n      this.state.results[this.state.previousValue] ||\n      [];\n\n    const Tooltip = this.props.tooltip;\n    const looksLikeUrl = value.match(/^https?:\\/\\//i);\n\n    const suggestedLinkTitle = this.suggestedLinkTitle;\n\n    const showCreateLink =\n      !!this.props.onCreateLink &&\n      !(suggestedLinkTitle === this.initialValue) &&\n      suggestedLinkTitle.length > 0 &&\n      !looksLikeUrl;\n\n    const showResults =\n      !!suggestedLinkTitle && (showCreateLink || results.length > 0);\n\n    return (\n      <Wrapper>\n        <Input\n          value={value}\n          placeholder={\n            showCreateLink\n              ? dictionary.findOrCreateDoc\n              : dictionary.searchOrPasteLink\n          }\n          onKeyDown={this.handleKeyDown}\n          onPaste={this.handlePaste}\n          onChange={this.handleChange}\n          autoFocus={this.href === \"\"}\n        />\n\n        <ToolbarButton onClick={this.handleOpenLink} disabled={!value}>\n          <Tooltip tooltip={dictionary.openLink} placement=\"top\">\n            <OpenIcon color={theme.toolbarItem} />\n          </Tooltip>\n        </ToolbarButton>\n        <ToolbarButton onClick={this.handleRemoveLink}>\n          <Tooltip tooltip={dictionary.removeLink} placement=\"top\">\n            {this.initialValue ? (\n              <TrashIcon color={theme.toolbarItem} />\n            ) : (\n              <CloseIcon color={theme.toolbarItem} />\n            )}\n          </Tooltip>\n        </ToolbarButton>\n\n        {showResults && (\n          <SearchResults id=\"link-search-results\">\n            {results.map((result, index) => (\n              <LinkSearchResult\n                key={result.url}\n                title={result.title}\n                subtitle={result.subtitle}\n                icon={<DocumentIcon color={theme.toolbarItem} />}\n                onMouseOver={() => this.handleFocusLink(index)}\n                onClick={this.handleSelectLink(result.url, result.title)}\n                selected={index === selectedIndex}\n              />\n            ))}\n\n            {showCreateLink && (\n              <LinkSearchResult\n                key=\"create\"\n                title={suggestedLinkTitle}\n                subtitle={dictionary.createNewDoc}\n                icon={<PlusIcon color={theme.toolbarItem} />}\n                onMouseOver={() => this.handleFocusLink(results.length)}\n                onClick={() => {\n                  this.handleCreateLink(suggestedLinkTitle);\n\n                  if (this.initialSelectionLength) {\n                    this.moveSelectionToEnd();\n                  }\n                }}\n                selected={results.length === selectedIndex}\n              />\n            )}\n          </SearchResults>\n        )}\n      </Wrapper>\n    );\n  }\n}\n\nconst Wrapper = styled(Flex)`\n  margin-left: -8px;\n  margin-right: -8px;\n  min-width: 336px;\n  pointer-events: all;\n`;\n\nconst SearchResults = styled.ol`\n  background: ${(props) => props.theme.toolbarBackground};\n  position: absolute;\n  top: 100%;\n  width: 100%;\n  height: auto;\n  left: 0;\n  padding: 4px 8px 8px;\n  margin: 0;\n  margin-top: -3px;\n  margin-bottom: 0;\n  border-radius: 0 0 4px 4px;\n  overflow-y: auto;\n  max-height: 25vh;\n\n  @media (hover: none) and (pointer: coarse) {\n    position: fixed;\n    top: auto;\n    bottom: 40px;\n    border-radius: 0;\n    max-height: 50vh;\n    padding: 8px 8px 4px;\n  }\n`;\n\nexport default withTheme(LinkEditor);\n","import styled from \"styled-components\";\n\nconst Separator = styled.div`\n  height: 24px;\n  width: 2px;\n  background: ${(props) => props.theme.toolbarItem};\n  opacity: 0.3;\n  display: inline-block;\n  margin-left: 8px;\n`;\n\nexport default Separator;\n","import * as React from \"react\";\nimport { EditorView } from \"prosemirror-view\";\nimport styled, { withTheme } from \"styled-components\";\nimport ToolbarButton from \"./ToolbarButton\";\nimport ToolbarSeparator from \"./ToolbarSeparator\";\nimport theme from \"../styles/theme\";\nimport { MenuItem } from \"../types\";\n\ntype Props = {\n  tooltip: typeof React.Component | React.FC<any>;\n  commands: Record<string, any>;\n  view: EditorView;\n  theme: typeof theme;\n  items: MenuItem[];\n};\n\nconst FlexibleWrapper = styled.div`\n  display: flex;\n`;\n\nclass ToolbarMenu extends React.Component<Props> {\n  render() {\n    const { view, items } = this.props;\n    const { state } = view;\n    const Tooltip = this.props.tooltip;\n\n    return (\n      <FlexibleWrapper>\n        {items.map((item, index) => {\n          if (item.name === \"separator\" && item.visible !== false) {\n            return <ToolbarSeparator key={index} />;\n          }\n          if (item.visible === false || !item.icon) {\n            return null;\n          }\n          const Icon = item.icon;\n          const isActive = item.active ? item.active(state) : false;\n\n          return (\n            <ToolbarButton\n              key={index}\n              onClick={() =>\n                item.name && this.props.commands[item.name](item.attrs)\n              }\n              active={isActive}\n            >\n              <Tooltip tooltip={item.tooltip} placement=\"top\">\n                <Icon color={this.props.theme.toolbarItem} />\n              </Tooltip>\n            </ToolbarButton>\n          );\n        })}\n      </FlexibleWrapper>\n    );\n  }\n}\n\nexport default withTheme(ToolbarMenu);\n","import styled from \"styled-components\";\n\nconst VisuallyHidden = styled.span`\n  position: absolute !important;\n  height: 1px;\n  width: 1px;\n  overflow: hidden;\n  clip: rect(1px 1px 1px 1px); /* IE6, IE7 */\n  clip: rect(1px, 1px, 1px, 1px);\n`;\n\nexport default VisuallyHidden;\n","import * as React from \"react\";\nimport capitalize from \"lodash/capitalize\";\nimport { Portal } from \"react-portal\";\nimport { EditorView } from \"prosemirror-view\";\nimport { findDomRefAtPos, findParentNode } from \"prosemirror-utils\";\nimport styled from \"styled-components\";\nimport { EmbedDescriptor, MenuItem, ToastType } from \"../types\";\nimport Input from \"./Input\";\nimport VisuallyHidden from \"./VisuallyHidden\";\nimport getDataTransferFiles from \"../lib/getDataTransferFiles\";\nimport filterExcessSeparators from \"../lib/filterExcessSeparators\";\nimport insertFiles from \"../commands/insertFiles\";\nimport baseDictionary from \"../dictionary\";\n\nconst SSR = typeof window === \"undefined\";\n\nconst defaultPosition = {\n  left: -1000,\n  top: 0,\n  bottom: undefined,\n  isAbove: false,\n};\ntype CommandMenuItems = EmbedDescriptor | MenuItem;\nexport type Props<T extends MenuItem = MenuItem> = {\n  rtl: boolean;\n  isActive: boolean;\n  commands: Record<string, any>;\n  dictionary: typeof baseDictionary;\n  view: EditorView;\n  search: string;\n  uploadImage?: (file: File) => Promise<string>;\n  onImageUploadStart?: () => void;\n  onImageUploadStop?: () => void;\n  onShowToast?: (message: string, id: string) => void;\n  onLinkToolbarOpen?: () => void;\n  onClose: () => void;\n  onClearSearch: () => void;\n  embeds?: EmbedDescriptor[];\n  renderMenuItem: (\n    item: T,\n    index: number,\n    options: {\n      selected: boolean;\n      onClick: () => void;\n    }\n  ) => React.ReactNode;\n  filterable?: boolean;\n  items: T[];\n  id?: string;\n};\n\ntype State = {\n  insertItem?: EmbedDescriptor;\n  left?: number;\n  top?: number;\n  bottom?: number;\n  isAbove: boolean;\n  selectedIndex: number;\n};\n\nclass CommandMenu<T extends MenuItem = MenuItem> extends React.Component<\n  Props<T>,\n  State\n> {\n  menuRef = React.createRef<HTMLDivElement>();\n  inputRef = React.createRef<HTMLInputElement>();\n\n  state: State = {\n    left: -1000,\n    top: 0,\n    bottom: undefined,\n    isAbove: false,\n    selectedIndex: 0,\n    insertItem: undefined,\n  };\n\n  componentDidMount() {\n    if (!SSR) {\n      window.addEventListener(\"keydown\", this.handleKeyDown);\n    }\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    return (\n      nextProps.search !== this.props.search ||\n      nextProps.isActive !== this.props.isActive ||\n      nextState !== this.state\n    );\n  }\n\n  componentDidUpdate(prevProps) {\n    if (!prevProps.isActive && this.props.isActive) {\n      const position = this.calculatePosition(this.props);\n\n      this.setState({\n        insertItem: undefined,\n        selectedIndex: 0,\n        ...position,\n      });\n    } else if (prevProps.search !== this.props.search) {\n      this.setState({ selectedIndex: 0 } as State);\n    }\n  }\n\n  componentWillUnmount() {\n    if (!SSR) {\n      window.removeEventListener(\"keydown\", this.handleKeyDown);\n    }\n  }\n\n  handleKeyDown = (event: KeyboardEvent) => {\n    if (!this.props.isActive) return;\n\n    if (event.key === \"Enter\") {\n      event.preventDefault();\n      event.stopPropagation();\n\n      const item = this.filtered[this.state.selectedIndex];\n\n      if (item) {\n        this.insertItem(item);\n      } else {\n        this.props.onClose();\n      }\n    }\n\n    if (\n      event.key === \"ArrowUp\" ||\n      (event.key === \"Tab\" && event.shiftKey) ||\n      (event.ctrlKey && event.key === \"p\")\n    ) {\n      event.preventDefault();\n      event.stopPropagation();\n\n      if (this.filtered.length) {\n        const prevIndex = this.state.selectedIndex - 1;\n        const prev = this.filtered[prevIndex];\n\n        this.setState({\n          selectedIndex: Math.max(\n            0,\n            prev && prev.name === \"separator\" ? prevIndex - 1 : prevIndex\n          ),\n        } as State);\n      } else {\n        this.close();\n      }\n    }\n\n    if (\n      event.key === \"ArrowDown\" ||\n      (event.key === \"Tab\" && !event.shiftKey) ||\n      (event.ctrlKey && event.key === \"n\")\n    ) {\n      event.preventDefault();\n      event.stopPropagation();\n\n      if (this.filtered.length) {\n        const total = this.filtered.length - 1;\n        const nextIndex = this.state.selectedIndex + 1;\n        const next = this.filtered[nextIndex];\n\n        this.setState({\n          selectedIndex: Math.min(\n            next && next.name === \"separator\" ? nextIndex + 1 : nextIndex,\n            total\n          ),\n        });\n      } else {\n        this.close();\n      }\n    }\n\n    if (event.key === \"Escape\") {\n      this.close();\n    }\n  };\n\n  insertItem = (item) => {\n    switch (item.name) {\n      case \"image\":\n        return this.triggerImagePick();\n      case \"embed\":\n        return this.triggerLinkInput(item);\n      case \"link\": {\n        this.clearSearch();\n        this.props.onClose();\n        this.props.onLinkToolbarOpen?.();\n        return;\n      }\n      default:\n        this.insertBlock(item);\n    }\n  };\n\n  close = () => {\n    this.props.onClose();\n    this.props.view.focus();\n  };\n\n  handleLinkInputKeydown = (event: React.KeyboardEvent<HTMLInputElement>) => {\n    if (!this.props.isActive) return;\n    if (!this.state.insertItem) return;\n\n    if (event.key === \"Enter\") {\n      event.preventDefault();\n      event.stopPropagation();\n\n      const href = event.currentTarget.value;\n      const matches = this.state.insertItem.matcher(href);\n\n      if (!matches && this.props.onShowToast) {\n        this.props.onShowToast(\n          this.props.dictionary.embedInvalidLink,\n          ToastType.Error\n        );\n        return;\n      }\n\n      this.insertBlock({\n        name: \"embed\",\n        attrs: {\n          href,\n        },\n      });\n    }\n\n    if (event.key === \"Escape\") {\n      this.props.onClose();\n      this.props.view.focus();\n    }\n  };\n\n  handleLinkInputPaste = (event: React.ClipboardEvent<HTMLInputElement>) => {\n    if (!this.props.isActive) return;\n    if (!this.state.insertItem) return;\n\n    const href = event.clipboardData.getData(\"text/plain\");\n    const matches = this.state.insertItem.matcher(href);\n\n    if (matches) {\n      event.preventDefault();\n      event.stopPropagation();\n\n      this.insertBlock({\n        name: \"embed\",\n        attrs: {\n          href,\n        },\n      });\n    }\n  };\n\n  triggerImagePick = () => {\n    if (this.inputRef.current) {\n      this.inputRef.current.click();\n    }\n  };\n\n  triggerLinkInput = (item) => {\n    this.setState({ insertItem: item });\n  };\n\n  handleImagePicked = (event) => {\n    const files = getDataTransferFiles(event);\n\n    const {\n      view,\n      uploadImage,\n      onImageUploadStart,\n      onImageUploadStop,\n      onShowToast,\n    } = this.props;\n    const { state } = view;\n    const parent = findParentNode((node) => !!node)(state.selection);\n\n    this.clearSearch();\n\n    if (!uploadImage) {\n      throw new Error(\"uploadImage prop is required to replace images\");\n    }\n\n    if (parent) {\n      insertFiles(view, event, parent.pos, files, {\n        uploadImage,\n        onImageUploadStart,\n        onImageUploadStop,\n        onShowToast,\n        dictionary: this.props.dictionary,\n      });\n    }\n\n    if (this.inputRef.current) {\n      this.inputRef.current.value = \"\";\n    }\n\n    this.props.onClose();\n  };\n\n  clearSearch = () => {\n    this.props.onClearSearch();\n  };\n\n  insertBlock(item) {\n    this.clearSearch();\n\n    const command = this.props.commands[item.name];\n\n    if (command) {\n      command(item.attrs);\n    } else {\n      this.props.commands[`create${capitalize(item.name)}`](item.attrs);\n    }\n\n    this.props.onClose();\n  }\n\n  get caretPosition(): { top: number; left: number } {\n    const selection = window.document.getSelection();\n    if (!selection || !selection.anchorNode || !selection.focusNode) {\n      return {\n        top: 0,\n        left: 0,\n      };\n    }\n\n    const range = window.document.createRange();\n    range.setStart(selection.anchorNode, selection.anchorOffset);\n    range.setEnd(selection.focusNode, selection.focusOffset);\n\n    // This is a workaround for an edgecase where getBoundingClientRect will\n    // return zero values if the selection is collapsed at the start of a newline\n    // see reference here: https://stackoverflow.com/a/59780954\n    const rects = range.getClientRects();\n    if (rects.length === 0) {\n      // probably buggy newline behavior, explicitly select the node contents\n      if (range.startContainer && range.collapsed) {\n        range.selectNodeContents(range.startContainer);\n      }\n    }\n\n    const rect = range.getBoundingClientRect();\n    return {\n      top: rect.top,\n      left: rect.left,\n    };\n  }\n\n  calculatePosition(props) {\n    const { view } = props;\n    const { selection } = view.state;\n    let startPos;\n    try {\n      startPos = view.coordsAtPos(selection.from);\n    } catch (err) {\n      console.warn(err);\n      return defaultPosition;\n    }\n\n    const domAtPos = view.domAtPos.bind(view);\n\n    const ref = this.menuRef.current;\n    const offsetHeight = ref ? ref.offsetHeight : 0;\n    const node = findDomRefAtPos(selection.from, domAtPos);\n    const paragraph: any = { node };\n\n    if (\n      !props.isActive ||\n      !paragraph.node ||\n      !paragraph.node.getBoundingClientRect ||\n      SSR\n    ) {\n      return defaultPosition;\n    }\n\n    const { left } = this.caretPosition;\n    const { top, bottom, right } = paragraph.node.getBoundingClientRect();\n    const margin = 24;\n\n    let leftPos = left + window.scrollX;\n    if (props.rtl && ref) {\n      leftPos = right - ref.scrollWidth;\n    }\n\n    if (startPos.top - offsetHeight > margin) {\n      return {\n        left: leftPos,\n        top: undefined,\n        bottom: window.innerHeight - top - window.scrollY,\n        isAbove: false,\n      };\n    } else {\n      return {\n        left: leftPos,\n        top: bottom + window.scrollY,\n        bottom: undefined,\n        isAbove: true,\n      };\n    }\n  }\n\n  get filtered() {\n    const {\n      embeds = [],\n      search = \"\",\n      uploadImage,\n      commands,\n      filterable = true,\n    } = this.props;\n    let items = this.props.items as CommandMenuItems[];\n    const embedItems: EmbedDescriptor[] = [];\n\n    for (const embed of embeds) {\n      if (embed.title && embed.icon) {\n        embedItems.push({\n          ...embed,\n          name: \"embed\",\n        });\n      }\n    }\n\n    if (embedItems.length) {\n      items.push({\n        name: \"separator\",\n      });\n      items = items.concat(embedItems);\n    }\n\n    const filtered = items.filter((item) => {\n      if (item.name === \"separator\") return true;\n\n      // Some extensions may be disabled, remove corresponding menu items\n      if (\n        item.name &&\n        !commands[item.name] &&\n        !commands[`create${capitalize(item.name)}`]\n      ) {\n        return false;\n      }\n\n      // If no image upload callback has been passed, filter the image block out\n      if (!uploadImage && item.name === \"image\") return false;\n\n      // some items (defaultHidden) are not visible until a search query exists\n      if (!search) return !item.defaultHidden;\n\n      const n = search.toLowerCase();\n      if (!filterable) {\n        return item;\n      }\n      return (\n        (item.title || \"\").toLowerCase().includes(n) ||\n        (item.keywords || \"\").toLowerCase().includes(n)\n      );\n    });\n\n    return filterExcessSeparators(filtered);\n  }\n\n  render() {\n    const { dictionary, isActive, uploadImage } = this.props;\n    const items = this.filtered;\n    const { insertItem, ...positioning } = this.state;\n\n    return (\n      <Portal>\n        <Wrapper\n          id={this.props.id || \"block-menu-container\"}\n          active={isActive}\n          ref={this.menuRef}\n          {...positioning}\n        >\n          {insertItem ? (\n            <LinkInputWrapper>\n              <LinkInput\n                type=\"text\"\n                placeholder={\n                  insertItem.title\n                    ? dictionary.pasteLinkWithTitle(insertItem.title)\n                    : dictionary.pasteLink\n                }\n                onKeyDown={this.handleLinkInputKeydown}\n                onPaste={this.handleLinkInputPaste}\n                autoFocus\n              />\n            </LinkInputWrapper>\n          ) : (\n            <List>\n              {items.map((item, index) => {\n                if (item.name === \"separator\") {\n                  return (\n                    <ListItem key={index}>\n                      <hr />\n                    </ListItem>\n                  );\n                }\n                const selected = index === this.state.selectedIndex && isActive;\n\n                if (!item.title) {\n                  return null;\n                }\n\n                return (\n                  <ListItem key={index}>\n                    {this.props.renderMenuItem(item as any, index, {\n                      selected,\n                      onClick: () => this.insertItem(item),\n                    })}\n                  </ListItem>\n                );\n              })}\n              {items.length === 0 && (\n                <ListItem>\n                  <Empty>{dictionary.noResults}</Empty>\n                </ListItem>\n              )}\n            </List>\n          )}\n          {uploadImage && (\n            <VisuallyHidden>\n              <input\n                type=\"file\"\n                ref={this.inputRef}\n                onChange={this.handleImagePicked}\n                accept=\"image/*\"\n              />\n            </VisuallyHidden>\n          )}\n        </Wrapper>\n      </Portal>\n    );\n  }\n}\n\nconst LinkInputWrapper = styled.div`\n  margin: 8px;\n`;\n\nconst LinkInput = styled(Input)`\n  height: 36px;\n  width: 100%;\n  color: ${(props) => props.theme.blockToolbarText};\n`;\n\nconst List = styled.ol`\n  list-style: none;\n  text-align: left;\n  height: 100%;\n  padding: 8px 0;\n  margin: 0;\n`;\n\nconst ListItem = styled.li`\n  padding: 0;\n  margin: 0;\n`;\n\nconst Empty = styled.div`\n  display: flex;\n  align-items: center;\n  color: ${(props) => props.theme.textSecondary};\n  font-weight: 500;\n  font-size: 14px;\n  height: 36px;\n  padding: 0 16px;\n`;\n\nexport const Wrapper = styled.div<{\n  active: boolean;\n  top?: number;\n  bottom?: number;\n  left?: number;\n  isAbove: boolean;\n}>`\n  color: ${(props) => props.theme.text};\n  font-family: ${(props) => props.theme.fontFamily};\n  position: absolute;\n  z-index: ${(props) => props.theme.zIndex + 100};\n  ${(props) => props.top !== undefined && `top: ${props.top}px`};\n  ${(props) => props.bottom !== undefined && `bottom: ${props.bottom}px`};\n  left: ${(props) => props.left}px;\n  background-color: ${(props) => props.theme.blockToolbarBackground};\n  border-radius: 4px;\n  box-shadow: rgba(0, 0, 0, 0.05) 0px 0px 0px 1px,\n    rgba(0, 0, 0, 0.08) 0px 4px 8px, rgba(0, 0, 0, 0.08) 0px 2px 4px;\n  opacity: 0;\n  transform: scale(0.95);\n  transition: opacity 150ms cubic-bezier(0.175, 0.885, 0.32, 1.275),\n    transform 150ms cubic-bezier(0.175, 0.885, 0.32, 1.275);\n  transition-delay: 150ms;\n  line-height: 0;\n  box-sizing: border-box;\n  pointer-events: none;\n  white-space: nowrap;\n  width: 300px;\n  max-height: 224px;\n  overflow: hidden;\n  overflow-y: auto;\n\n  * {\n    box-sizing: border-box;\n  }\n\n  hr {\n    border: 0;\n    height: 0;\n    border-top: 1px solid ${(props) => props.theme.blockToolbarDivider};\n  }\n\n  ${({ active, isAbove }) =>\n    active &&\n    `\n    transform: translateY(${isAbove ? \"6px\" : \"-6px\"}) scale(1);\n    pointer-events: all;\n    opacity: 1;\n  `};\n\n  @media print {\n    display: none;\n  }\n`;\n\nexport default CommandMenu;\n","import * as React from \"react\";\nimport scrollIntoView from \"smooth-scroll-into-view-if-needed\";\nimport styled, { withTheme } from \"styled-components\";\nimport theme from \"../styles/theme\";\n\nexport type Props = {\n  selected: boolean;\n  disabled?: boolean;\n  onClick: () => void;\n  theme: typeof theme;\n  icon?: typeof React.Component | React.FC<any>;\n  title: React.ReactNode;\n  shortcut?: string;\n  containerId?: string;\n};\n\nfunction BlockMenuItem({\n  selected,\n  disabled,\n  onClick,\n  title,\n  shortcut,\n  icon,\n  containerId = \"block-menu-container\",\n}: Props) {\n  const Icon = icon;\n\n  const ref = React.useCallback(\n    (node) => {\n      if (selected && node) {\n        scrollIntoView(node, {\n          scrollMode: \"if-needed\",\n          block: \"center\",\n          boundary: (parent) => {\n            // All the parent elements of your target are checked until they\n            // reach the #block-menu-container. Prevents body and other parent\n            // elements from being scrolled\n            return parent.id !== containerId;\n          },\n        });\n      }\n    },\n    [selected, containerId]\n  );\n\n  return (\n    <MenuItem\n      selected={selected}\n      onClick={disabled ? undefined : onClick}\n      ref={ref}\n    >\n      {Icon && (\n        <>\n          <Icon\n            color={\n              selected ? theme.blockToolbarIconSelected : theme.blockToolbarIcon\n            }\n          />\n          &nbsp;&nbsp;\n        </>\n      )}\n      {title}\n      {shortcut && <Shortcut>{shortcut}</Shortcut>}\n    </MenuItem>\n  );\n}\n\nconst MenuItem = styled.button<{\n  selected: boolean;\n}>`\n  display: flex;\n  align-items: center;\n  justify-content: flex-start;\n  font-weight: 500;\n  font-size: 14px;\n  line-height: 1;\n  width: 100%;\n  height: 36px;\n  cursor: pointer;\n  border: none;\n  opacity: ${(props) => (props.disabled ? \".5\" : \"1\")};\n  color: ${(props) =>\n    props.selected\n      ? props.theme.blockToolbarTextSelected\n      : props.theme.blockToolbarText};\n  background: ${(props) =>\n    props.selected\n      ? props.theme.blockToolbarSelectedBackground ||\n        props.theme.blockToolbarTrigger\n      : \"none\"};\n  padding: 0 16px;\n  outline: none;\n\n  &:hover,\n  &:active {\n    color: ${(props) => props.theme.blockToolbarTextSelected};\n    background: ${(props) =>\n      props.selected\n        ? props.theme.blockToolbarSelectedBackground ||\n          props.theme.blockToolbarTrigger\n        : props.theme.blockToolbarHoverBackground};\n  }\n`;\n\nconst Shortcut = styled.span`\n  color: ${(props) => props.theme.textSecondary};\n  flex-grow: 1;\n  text-align: right;\n`;\n\nexport default withTheme(BlockMenuItem);\n","import * as React from \"react\";\nimport BlockMenuItem, { Props as BlockMenuItemProps } from \"./BlockMenuItem\";\nimport styled from \"styled-components\";\n\nconst Emoji = styled.span`\n  font-size: 16px;\n`;\n\nconst EmojiTitle = ({\n  emoji,\n  title,\n}: {\n  emoji: React.ReactNode;\n  title: React.ReactNode;\n}) => {\n  return (\n    <p>\n      <Emoji className=\"emoji\">{emoji}</Emoji>\n      &nbsp;&nbsp;\n      {title}\n    </p>\n  );\n};\n\ntype EmojiMenuItemProps = Omit<BlockMenuItemProps, \"shortcut\" | \"theme\"> & {\n  emoji: string;\n};\n\nexport default function EmojiMenuItem(props: EmojiMenuItemProps) {\n  return (\n    <BlockMenuItem\n      {...props}\n      title={<EmojiTitle emoji={props.emoji} title={props.title} />}\n    />\n  );\n}\n","import styled from \"styled-components\";\n\nexport const StyledEditor = styled(\"div\")<{\n  rtl: boolean;\n  readOnly?: boolean;\n  readOnlyWriteCheckboxes?: boolean;\n}>`\n  color: ${(props) => props.theme.text};\n  background: ${(props) => props.theme.background};\n  font-family: ${(props) => props.theme.fontFamily};\n  font-weight: ${(props) => props.theme.fontWeight};\n  font-size: 1em;\n  line-height: 1.7em;\n  width: 100%;\n\n  .ProseMirror {\n    position: relative;\n    outline: none;\n    word-wrap: break-word;\n    white-space: pre-wrap;\n    white-space: break-spaces;\n    -webkit-font-variant-ligatures: none;\n    font-variant-ligatures: none;\n    font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n  }\n\n  pre {\n    white-space: pre-wrap;\n  }\n\n  li {\n    position: relative;\n  }\n\n  .image {\n    text-align: center;\n    max-width: 100%;\n    clear: both;\n\n    img {\n      pointer-events: ${(props) => (props.readOnly ? \"initial\" : \"none\")};\n      display: inline-block;\n      max-width: 100%;\n      max-height: 75vh;\n    }\n\n    .ProseMirror-selectednode img {\n      pointer-events: initial;\n    }\n  }\n\n  .image.placeholder {\n    position: relative;\n    background: ${(props) => props.theme.background};\n    margin-bottom: calc(28px + 1.2em);\n\n    img {\n      opacity: 0.5;\n    }\n  }\n\n  .image-replacement-uploading {\n    img {\n      opacity: 0.5;\n    }\n  }\n\n  .image-right-50 {\n    float: right;\n    width: 50%;\n    margin-left: 2em;\n    margin-bottom: 1em;\n    clear: initial;\n  }\n\n  .image-left-50 {\n    float: left;\n    width: 50%;\n    margin-right: 2em;\n    margin-bottom: 1em;\n    clear: initial;\n  }\n\n  .ProseMirror-hideselection *::selection {\n    background: transparent;\n  }\n  .ProseMirror-hideselection *::-moz-selection {\n    background: transparent;\n  }\n  .ProseMirror-hideselection {\n    caret-color: transparent;\n  }\n\n  .ProseMirror-selectednode {\n    outline: 2px solid\n      ${(props) => (props.readOnly ? \"transparent\" : props.theme.selected)};\n  }\n\n  /* Make sure li selections wrap around markers */\n\n  li.ProseMirror-selectednode {\n    outline: none;\n  }\n\n  li.ProseMirror-selectednode:after {\n    content: \"\";\n    position: absolute;\n    left: ${(props) => (props.rtl ? \"-2px\" : \"-32px\")};\n    right: ${(props) => (props.rtl ? \"-32px\" : \"-2px\")};\n    top: -2px;\n    bottom: -2px;\n    border: 2px solid ${(props) => props.theme.selected};\n    pointer-events: none;\n  }\n\n  .ProseMirror[contenteditable=\"false\"] {\n    .caption {\n      pointer-events: none;\n    }\n    .caption:empty {\n      visibility: hidden;\n    }\n  }\n\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6 {\n    margin: 1em 0 0.5em;\n    font-weight: 500;\n    cursor: text;\n\n    &:not(.placeholder):before {\n      display: ${(props) => (props.readOnly ? \"none\" : \"inline-block\")};\n      font-family: ${(props) => props.theme.fontFamilyMono};\n      color: ${(props) => props.theme.textSecondary};\n      font-size: 13px;\n      line-height: 0;\n      margin-${(props) => (props.rtl ? \"right\" : \"left\")}: -24px;\n      transition: opacity 150ms ease-in-out;\n      opacity: 0;\n      width: 24px;\n    }\n\n    &:hover,\n    &:focus-within {\n      .heading-actions {\n        opacity: 1;\n      }\n    }\n  }\n\n  .heading-content {\n    &:before {\n      content: \"\";\n      display: inline;\n    }\n  }\n\n  .heading-name {\n    color: ${(props) => props.theme.text};\n\n    &:hover {\n      text-decoration: none;\n    }\n  }\n\n  a:first-child {\n    h1,\n    h2,\n    h3,\n    h4,\n    h5,\n    h6 {\n      margin-top: 0;\n    }\n  }\n\n  h1:not(.placeholder):before {\n    content: \"H1\";\n  }\n  h2:not(.placeholder):before {\n    content: \"H2\";\n  }\n  h3:not(.placeholder):before {\n    content: \"H3\";\n  }\n  h4:not(.placeholder):before {\n    content: \"H4\";\n  }\n  h5:not(.placeholder):before {\n    content: \"H5\";\n  }\n  h6:not(.placeholder):before {\n    content: \"H6\";\n  }\n\n  .ProseMirror-focused {\n    h1,\n    h2,\n    h3,\n    h4,\n    h5,\n    h6 {\n      &:not(.placeholder):before {\n        opacity: 1;\n      }\n    }\n  }\n\n  .with-emoji {\n    margin-${(props) => (props.rtl ? \"right\" : \"left\")}: -1em;\n  }\n\n  .heading-anchor,\n  .heading-fold {\n    display: inline-block;\n    color: ${(props) => props.theme.text};\n    opacity: .75;\n    cursor: pointer;\n    background: none;\n    outline: none;\n    border: 0;\n    margin: 0;\n    padding: 0;\n    text-align: left;\n    font-family: ${(props) => props.theme.fontFamilyMono};\n    font-size: 14px;\n    line-height: 0;\n    width: 12px;\n    height: 24px;\n\n    &:focus,\n    &:hover {\n      opacity: 1;\n    }\n  }\n\n  .heading-actions {\n    opacity: 0;\n    background: ${(props) => props.theme.background};\n    margin-${(props) => (props.rtl ? \"right\" : \"left\")}: -26px;\n    flex-direction: ${(props) => (props.rtl ? \"row-reverse\" : \"row\")};\n    display: inline-flex;\n    position: relative;\n    top: -2px;\n    width: 26px;\n    height: 24px;\n\n    &.collapsed {\n      opacity: 1;\n    }\n\n    &.collapsed .heading-anchor {\n      opacity: 0;\n    }\n\n    &.collapsed .heading-fold {\n      opacity: 1;\n    }\n  }\n\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6 {\n    &:hover {\n      .heading-anchor {\n        opacity: 0.75 !important;\n      }\n      .heading-anchor:hover {\n        opacity: 1 !important;\n      }\n    }\n  }\n\n  .heading-fold {\n    display: inline-block;\n    transform-origin: center;\n    padding: 0;\n\n    &.collapsed {\n      transform: rotate(${(props) => (props.rtl ? \"90deg\" : \"-90deg\")});\n      transition-delay: 0.1s;\n      opacity: 1;\n    }\n  }\n\n  .placeholder:before {\n    display: block;\n    opacity: 0;\n    transition: opacity 150ms ease-in-out;\n    content: ${(props) => (props.readOnly ? \"\" : \"attr(data-empty-text)\")};\n    pointer-events: none;\n    height: 0;\n    color: ${(props) => props.theme.placeholder};\n  }\n\n  /** Show the placeholder if focused or the first visible item nth(2) accounts for block insert trigger */\n  .ProseMirror-focused .placeholder:before,\n  .placeholder:nth-child(1):before,\n  .placeholder:nth-child(2):before {\n    opacity: 1;\n  }\n\n  .notice-block {\n    display: flex;\n    align-items: center;\n    background: ${(props) => props.theme.noticeInfoBackground};\n    color: ${(props) => props.theme.noticeInfoText};\n    border-radius: 4px;\n    padding: 8px 16px;\n    margin: 8px 0;\n\n    a {\n      color: ${(props) => props.theme.noticeInfoText};\n    }\n\n    a:not(.heading-name) {\n      text-decoration: underline;\n    }\n  }\n\n  .notice-block .content {\n    flex-grow: 1;\n    min-width: 0;\n  }\n\n  .notice-block .icon {\n    width: 24px;\n    height: 24px;\n    align-self: flex-start;\n    margin-${(props) => (props.rtl ? \"left\" : \"right\")}: 4px;\n    position: relative;\n    top: 1px;\n  }\n\n  .notice-block.tip {\n    background: ${(props) => props.theme.noticeTipBackground};\n    color: ${(props) => props.theme.noticeTipText};\n\n    a {\n      color: ${(props) => props.theme.noticeTipText};\n    }\n  }\n\n  .notice-block.warning {\n    background: ${(props) => props.theme.noticeWarningBackground};\n    color: ${(props) => props.theme.noticeWarningText};\n\n    a {\n      color: ${(props) => props.theme.noticeWarningText};\n    }\n  }\n\n  blockquote {\n    margin: 0;\n    padding-left: 1.5em;\n    font-style: italic;\n    overflow: hidden;\n    position: relative;\n\n    &:before {\n      content: \"\";\n      display: inline-block;\n      width: 2px;\n      border-radius: 1px;\n      position: absolute;\n      margin-${(props) => (props.rtl ? \"right\" : \"left\")}: -1.5em;\n      top: 0;\n      bottom: 0;\n      background: ${(props) => props.theme.quote};\n    }\n  }\n\n  b,\n  strong {\n    font-weight: 600;\n  }\n\n  .template-placeholder {\n    color: ${(props) => props.theme.placeholder};\n    border-bottom: 1px dotted ${(props) => props.theme.placeholder};\n    border-radius: 2px;\n    cursor: text;\n\n    &:hover {\n      border-bottom: 1px dotted\n        ${(props) =>\n          props.readOnly ? props.theme.placeholder : props.theme.textSecondary};\n    }\n  }\n\n  p {\n    margin: 0;\n\n    span:first-child + br:last-child {\n      display: none;\n    }\n  }\n\n  a {\n    color: ${(props) => props.theme.link};\n    cursor: pointer;\n  }\n\n  a:hover {\n    text-decoration: ${(props) => (props.readOnly ? \"underline\" : \"none\")};\n  }\n\n  ul,\n  ol {\n    margin: ${(props) => (props.rtl ? \"0 -26px 0 0.1em\" : \"0 0.1em 0 -26px\")};\n    padding: ${(props) => (props.rtl ? \"0 44px 0 0\" : \"0 0 0 44px\")};\n  }\n\n  ol ol {\n    list-style: lower-alpha;\n  }\n\n  ol ol ol {\n    list-style: lower-roman;\n  }\n\n  ul.checkbox_list {\n    list-style: none;\n    padding: 0;\n    margin: ${(props) => (props.rtl ? \"0 -24px 0 0\" : \"0 0 0 -24px\")};\n  }\n\n  ul li,\n  ol li {\n    position: relative;\n    white-space: initial;\n\n    p {\n      white-space: pre-wrap;\n    }\n\n    > div {\n      width: 100%;\n    }\n  }\n\n  ul.checkbox_list li {\n    display: flex;\n    padding-${(props) => (props.rtl ? \"right\" : \"left\")}: 24px;\n  }\n\n  ul.checkbox_list li.checked > div > p {\n    color: ${(props) => props.theme.textSecondary};\n    text-decoration: line-through;\n  }\n\n  ul li::before,\n  ol li::before {\n    background: url(\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3QgeD0iOCIgeT0iNyIgd2lkdGg9IjMiIGhlaWdodD0iMiIgcng9IjEiIGZpbGw9IiM0RTVDNkUiLz4KPHJlY3QgeD0iOCIgeT0iMTEiIHdpZHRoPSIzIiBoZWlnaHQ9IjIiIHJ4PSIxIiBmaWxsPSIjNEU1QzZFIi8+CjxyZWN0IHg9IjgiIHk9IjE1IiB3aWR0aD0iMyIgaGVpZ2h0PSIyIiByeD0iMSIgZmlsbD0iIzRFNUM2RSIvPgo8cmVjdCB4PSIxMyIgeT0iNyIgd2lkdGg9IjMiIGhlaWdodD0iMiIgcng9IjEiIGZpbGw9IiM0RTVDNkUiLz4KPHJlY3QgeD0iMTMiIHk9IjExIiB3aWR0aD0iMyIgaGVpZ2h0PSIyIiByeD0iMSIgZmlsbD0iIzRFNUM2RSIvPgo8cmVjdCB4PSIxMyIgeT0iMTUiIHdpZHRoPSIzIiBoZWlnaHQ9IjIiIHJ4PSIxIiBmaWxsPSIjNEU1QzZFIi8+Cjwvc3ZnPgo=\") no-repeat;\n    background-position: 0 2px;\n    content: \"\";\n    display: ${(props) => (props.readOnly ? \"none\" : \"inline-block\")};\n    cursor: grab;\n    width: 24px;\n    height: 24px;\n    position: absolute;\n    ${(props) => (props.rtl ? \"right\" : \"left\")}: -40px;\n    opacity: 0;\n    transition: opacity 200ms ease-in-out;\n  }\n\n  ul li[draggable=true]::before,\n  ol li[draggable=true]::before {\n    cursor: grabbing;\n  }\n\n  ul > li.counter-2::before,\n  ol li.counter-2::before {\n    ${(props) => (props.rtl ? \"right\" : \"left\")}: -50px;\n  }\n\n  ul > li.hovering::before,\n  ol li.hovering::before {\n    opacity: 0.5;\n  }\n\n  ul li.ProseMirror-selectednode::after,\n  ol li.ProseMirror-selectednode::after {\n    display: none;\n  }\n\n  ul.checkbox_list li::before {\n    ${(props) => (props.rtl ? \"right\" : \"left\")}: 0;\n  }\n\n  ul.checkbox_list li input {\n    cursor: pointer;\n    pointer-events: ${(props) =>\n      props.readOnly && !props.readOnlyWriteCheckboxes ? \"none\" : \"initial\"};\n    opacity: ${(props) =>\n      props.readOnly && !props.readOnlyWriteCheckboxes ? 0.75 : 1};\n    margin: ${(props) => (props.rtl ? \"0.5em 0 0 0.5em\" : \"0.5em 0.5em 0 0\")};\n    width: 14px;\n    height: 14px;\n  }\n\n  li p:first-child {\n    margin: 0;\n    word-break: break-word;\n  }\n\n  hr {\n    position: relative;\n    height: 1em;\n    border: 0;\n  }\n\n  hr:before {\n    content: \"\";\n    display: block;\n    position: absolute;\n    border-top: 1px solid ${(props) => props.theme.horizontalRule};\n    top: 0.5em;\n    left: 0;\n    right: 0;\n  }\n\n  hr.page-break {\n    page-break-after: always;\n  }\n\n  hr.page-break:before {\n    border-top: 1px dashed ${(props) => props.theme.horizontalRule};\n  }\n\n  code {\n    border-radius: 4px;\n    border: 1px solid ${(props) => props.theme.codeBorder};\n    background: ${(props) => props.theme.codeBackground};\n    padding: 3px 4px;\n    font-family: ${(props) => props.theme.fontFamilyMono};\n    font-size: 80%;\n  }\n\n  mark {\n    border-radius: 1px;\n    color: ${(props) => props.theme.textHighlightForeground};\n    background: ${(props) => props.theme.textHighlight};\n\n    a {\n      color: ${(props) => props.theme.textHighlightForeground};\n    }\n  }\n\n  .code-block,\n  .notice-block {\n    position: relative;\n\n    select,\n    button {\n      background: ${(props) => props.theme.blockToolbarBackground};\n      color: ${(props) => props.theme.blockToolbarItem};\n      border-width: 1px;\n      font-size: 13px;\n      display: none;\n      position: absolute;\n      border-radius: 4px;\n      padding: 2px;\n      z-index: 1;\n      top: 4px;\n    }\n\n    &.code-block {\n      select,\n      button {\n        right: 4px;\n      }\n    }\n\n    &.notice-block {\n      select,\n      button {\n        ${(props) => (props.rtl ? \"left\" : \"right\")}: 4px;\n      }\n    }\n\n    button {\n      padding: 2px 4px;\n    }\n\n    &:hover {\n      select {\n        display: ${(props) => (props.readOnly ? \"none\" : \"inline\")};\n      }\n\n      button {\n        display: ${(props) => (props.readOnly ? \"inline\" : \"none\")};\n      }\n    }\n\n    select:focus,\n    select:active {\n      display: inline;\n    }\n  }\n\n  pre {\n    display: block;\n    overflow-x: auto;\n    padding: 0.75em 1em;\n    line-height: 1.4em;\n    position: relative;\n    background: ${(props) => props.theme.codeBackground};\n    border-radius: 4px;\n    border: 1px solid ${(props) => props.theme.codeBorder};\n\n    -webkit-font-smoothing: initial;\n    font-family: ${(props) => props.theme.fontFamilyMono};\n    font-size: 13px;\n    direction: ltr;\n    text-align: left;\n    white-space: pre;\n    word-spacing: normal;\n    word-break: normal;\n    -moz-tab-size: 4;\n    -o-tab-size: 4;\n    tab-size: 4;\n    -webkit-hyphens: none;\n    -moz-hyphens: none;\n    -ms-hyphens: none;\n    hyphens: none;\n    color: ${(props) => props.theme.code};\n    margin: 0;\n\n    code {\n      font-size: 13px;\n      background: none;\n      padding: 0;\n      border: 0;\n    }\n  }\n\n  .token.comment,\n  .token.prolog,\n  .token.doctype,\n  .token.cdata {\n    color: ${(props) => props.theme.codeComment};\n  }\n\n  .token.punctuation {\n    color: ${(props) => props.theme.codePunctuation};\n  }\n\n  .token.namespace {\n    opacity: 0.7;\n  }\n\n  .token.operator,\n  .token.boolean,\n  .token.number {\n    color: ${(props) => props.theme.codeNumber};\n  }\n\n  .token.property {\n    color: ${(props) => props.theme.codeProperty};\n  }\n\n  .token.tag {\n    color: ${(props) => props.theme.codeTag};\n  }\n\n  .token.string {\n    color: ${(props) => props.theme.codeString};\n  }\n\n  .token.selector {\n    color: ${(props) => props.theme.codeSelector};\n  }\n\n  .token.attr-name {\n    color: ${(props) => props.theme.codeAttr};\n  }\n\n  .token.entity,\n  .token.url,\n  .language-css .token.string,\n  .style .token.string {\n    color: ${(props) => props.theme.codeEntity};\n  }\n\n  .token.attr-value,\n  .token.keyword,\n  .token.control,\n  .token.directive,\n  .token.unit {\n    color: ${(props) => props.theme.codeKeyword};\n  }\n\n  .token.function {\n    color: ${(props) => props.theme.codeFunction};\n  }\n\n  .token.statement,\n  .token.regex,\n  .token.atrule {\n    color: ${(props) => props.theme.codeStatement};\n  }\n\n  .token.placeholder,\n  .token.variable {\n    color: ${(props) => props.theme.codePlaceholder};\n  }\n\n  .token.deleted {\n    text-decoration: line-through;\n  }\n\n  .token.inserted {\n    border-bottom: 1px dotted ${(props) => props.theme.codeInserted};\n    text-decoration: none;\n  }\n\n  .token.italic {\n    font-style: italic;\n  }\n\n  .token.important,\n  .token.bold {\n    font-weight: bold;\n  }\n\n  .token.important {\n    color: ${(props) => props.theme.codeImportant};\n  }\n\n  .token.entity {\n    cursor: help;\n  }\n\n  table {\n    width: 100%;\n    border-collapse: collapse;\n    border-radius: 4px;\n    margin-top: 1em;\n    box-sizing: border-box;\n\n    * {\n      box-sizing: border-box;\n    }\n\n    tr {\n      position: relative;\n      border-bottom: 1px solid ${(props) => props.theme.tableDivider};\n    }\n\n    th {\n      background: ${(props) => props.theme.tableHeaderBackground};\n    }\n\n    td,\n    th {\n      position: relative;\n      vertical-align: top;\n      border: 1px solid ${(props) => props.theme.tableDivider};\n      position: relative;\n      padding: 4px 8px;\n      text-align: ${(props) => (props.rtl ? \"right\" : \"left\")};\n      min-width: 100px;\n    }\n\n    .selectedCell {\n      background: ${(props) =>\n        props.readOnly ? \"inherit\" : props.theme.tableSelectedBackground};\n\n      /* fixes Firefox background color painting over border:\n       * https://bugzilla.mozilla.org/show_bug.cgi?id=688556 */\n      background-clip: padding-box;\n    }\n\n    .grip-column {\n      /* usage of ::after for all of the table grips works around a bug in\n       * prosemirror-tables that causes Safari to hang when selecting a cell\n       * in an empty table:\n       * https://github.com/ProseMirror/prosemirror/issues/947 */\n      &::after {\n        content: \"\";\n        cursor: pointer;\n        position: absolute;\n        top: -16px;\n        ${(props) => (props.rtl ? \"right\" : \"left\")}: 0;\n        width: 100%;\n        height: 12px;\n        background: ${(props) => props.theme.tableDivider};\n        border-bottom: 3px solid ${(props) => props.theme.background};\n        display: ${(props) => (props.readOnly ? \"none\" : \"block\")};\n      }\n\n      &:hover::after {\n        background: ${(props) => props.theme.text};\n      }\n      &.first::after {\n        border-top-${(props) => (props.rtl ? \"right\" : \"left\")}-radius: 3px;\n      }\n      &.last::after {\n        border-top-${(props) => (props.rtl ? \"left\" : \"right\")}-radius: 3px;\n      }\n      &.selected::after {\n        background: ${(props) => props.theme.tableSelected};\n      }\n    }\n\n    .grip-row {\n      &::after {\n        content: \"\";\n        cursor: pointer;\n        position: absolute;\n        ${(props) => (props.rtl ? \"right\" : \"left\")}: -16px;\n        top: 0;\n        height: 100%;\n        width: 12px;\n        background: ${(props) => props.theme.tableDivider};\n        border-${(props) => (props.rtl ? \"left\" : \"right\")}: 3px solid;\n        border-color: ${(props) => props.theme.background};\n        display: ${(props) => (props.readOnly ? \"none\" : \"block\")};\n      }\n\n      &:hover::after {\n        background: ${(props) => props.theme.text};\n      }\n      &.first::after {\n        border-top-${(props) => (props.rtl ? \"right\" : \"left\")}-radius: 3px;\n      }\n      &.last::after {\n        border-bottom-${(props) => (props.rtl ? \"right\" : \"left\")}-radius: 3px;\n      }\n      &.selected::after {\n        background: ${(props) => props.theme.tableSelected};\n      }\n    }\n\n    .grip-table {\n      &::after {\n        content: \"\";\n        cursor: pointer;\n        background: ${(props) => props.theme.tableDivider};\n        width: 13px;\n        height: 13px;\n        border-radius: 13px;\n        border: 2px solid ${(props) => props.theme.background};\n        position: absolute;\n        top: -18px;\n        ${(props) => (props.rtl ? \"right\" : \"left\")}: -18px;\n        display: ${(props) => (props.readOnly ? \"none\" : \"block\")};\n      }\n\n      &:hover::after {\n        background: ${(props) => props.theme.text};\n      }\n      &.selected::after {\n        background: ${(props) => props.theme.tableSelected};\n      }\n    }\n  }\n\n  .scrollable-wrapper {\n    position: relative;\n    margin: 0.5em 0px;\n    scrollbar-width: thin;\n    scrollbar-color: transparent transparent;\n\n    &:hover {\n      scrollbar-color: ${(props) => props.theme.scrollbarThumb} ${(props) =>\n  props.theme.scrollbarBackground};\n    }\n\n    & ::-webkit-scrollbar {\n      height: 14px;\n      background-color: transparent;\n    }\n\n    &:hover ::-webkit-scrollbar {\n      background-color: ${(props) => props.theme.scrollbarBackground};\n    }\n\n    & ::-webkit-scrollbar-thumb {\n      background-color: transparent;\n      border: 3px solid transparent;\n      border-radius: 7px;\n    }\n\n    &:hover ::-webkit-scrollbar-thumb {\n      background-color: ${(props) => props.theme.scrollbarThumb};\n      border-color: ${(props) => props.theme.scrollbarBackground};\n    }\n  }\n\n  .scrollable {\n    overflow-y: hidden;\n    overflow-x: auto;\n    padding-${(props) => (props.rtl ? \"right\" : \"left\")}: 1em;\n    margin-${(props) => (props.rtl ? \"right\" : \"left\")}: -1em;\n    border-${(props) => (props.rtl ? \"right\" : \"left\")}: 1px solid transparent;\n    border-${(props) => (props.rtl ? \"left\" : \"right\")}: 1px solid transparent;\n    transition: border 250ms ease-in-out 0s;\n  }\n\n  .scrollable-shadow {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    ${(props) => (props.rtl ? \"right\" : \"left\")}: -1em;\n    width: 16px;\n    transition: box-shadow 250ms ease-in-out;\n    border: 0px solid transparent;\n    border-${(props) => (props.rtl ? \"right\" : \"left\")}-width: 1em;\n    pointer-events: none;\n\n    &.left {\n      box-shadow: 16px 0 16px -16px inset rgba(0, 0, 0, 0.25);\n      border-left: 1em solid ${(props) => props.theme.background};\n    }\n\n    &.right {\n      right: 0;\n      left: auto;\n      box-shadow: -16px 0 16px -16px inset rgba(0, 0, 0, 0.25);\n    }\n  }\n\n  .block-menu-trigger {\n    opacity: 0;\n    pointer-events: none;\n    display: ${(props) => (props.readOnly ? \"none\" : \"inline\")};\n    width: 24px;\n    height: 24px;\n    color: ${(props) => props.theme.textSecondary};\n    background: none;\n    position: absolute;\n    transition: color 150ms cubic-bezier(0.175, 0.885, 0.32, 1.275),\n      transform 150ms cubic-bezier(0.175, 0.885, 0.32, 1.275),\n      opacity 150ms ease-in-out;\n    outline: none;\n    border: 0;\n    padding: 0;\n    margin-top: 1px;\n    margin-${(props) => (props.rtl ? \"right\" : \"left\")}: -24px;\n\n    &:hover,\n    &:focus {\n      cursor: pointer;\n      transform: scale(1.2);\n      color: ${(props) => props.theme.text};\n    }\n  }\n\n  .ProseMirror-focused .block-menu-trigger,\n  .block-menu-trigger:active,\n  .block-menu-trigger:focus {\n    opacity: 1;\n    pointer-events: initial;\n  }\n\n  .ProseMirror-gapcursor {\n    display: none;\n    pointer-events: none;\n    position: absolute;\n  }\n\n  .ProseMirror-gapcursor:after {\n    content: \"\";\n    display: block;\n    position: absolute;\n    top: -2px;\n    width: 20px;\n    border-top: 1px solid ${(props) => props.theme.cursor};\n    animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n  }\n\n  .folded-content {\n    display: none;\n  }\n\n  @keyframes ProseMirror-cursor-blink {\n    to {\n      visibility: hidden;\n    }\n  }\n\n  .ProseMirror-focused .ProseMirror-gapcursor {\n    display: block;\n  }\n\n  @media print {\n    .placeholder:before,\n    .block-menu-trigger,\n    .heading-actions,\n    h1:not(.placeholder):before,\n    h2:not(.placeholder):before,\n    h3:not(.placeholder):before,\n    h4:not(.placeholder):before,\n    h5:not(.placeholder):before,\n    h6:not(.placeholder):before {\n      display: none;\n    }\n\n    .page-break {\n      opacity: 0;\n    }\n\n    em,\n    blockquote {\n      font-family: \"SF Pro Text\", ${(props) => props.theme.fontFamily};\n    }\n  }\n`;\n","/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { InputRule } from \"prosemirror-inputrules\";\nimport { Plugin } from \"prosemirror-state\";\nimport Editor from \"../\";\nimport { PluginSimple } from \"markdown-it\";\n\ntype Command = (attrs) => (state, dispatch) => any;\n\nexport default class Extension {\n  options: Record<string, any>;\n  editor: Editor;\n\n  constructor(options: Record<string, any> = {}) {\n    this.options = {\n      ...this.defaultOptions,\n      ...options,\n    };\n  }\n\n  bindEditor(editor: Editor) {\n    this.editor = editor;\n  }\n\n  get type() {\n    return \"extension\";\n  }\n\n  get name() {\n    return \"\";\n  }\n\n  get plugins(): Plugin[] {\n    return [];\n  }\n\n  get rulePlugins(): PluginSimple[] {\n    return [];\n  }\n\n  keys(options) {\n    return {};\n  }\n\n  inputRules(options): InputRule[] {\n    return [];\n  }\n\n  commands(options): Record<string, Command> | Command {\n    return (attrs) => () => false;\n  }\n\n  get defaultOptions() {\n    return {};\n  }\n}\n","import * as React from \"react\";\nimport { DownloadIcon } from \"outline-icons\";\nimport { Plugin, TextSelection, NodeSelection } from \"prosemirror-state\";\nimport { InputRule } from \"prosemirror-inputrules\";\nimport styled from \"styled-components\";\nimport ImageZoom from \"react-medium-image-zoom\";\nimport getDataTransferFiles from \"../lib/getDataTransferFiles\";\nimport uploadPlaceholderPlugin from \"../lib/uploadPlaceholder\";\nimport insertFiles from \"../commands/insertFiles\";\nimport Node from \"./Node\";\n\n/**\n * Matches following attributes in Markdown-typed image: [, alt, src, class]\n *\n * Example:\n * ![Lorem](image.jpg) -> [, \"Lorem\", \"image.jpg\"]\n * ![](image.jpg \"class\") -> [, \"\", \"image.jpg\", \"small\"]\n * ![Lorem](image.jpg \"class\") -> [, \"Lorem\", \"image.jpg\", \"small\"]\n */\nconst IMAGE_INPUT_REGEX =\n  /!\\[(?<alt>[^\\]\\[]*?)]\\((?<filename>[^\\]\\[]*?)(?=\\|\\))\\?(?<layoutclass>[^\\]\\[\\]+)?\\?\\)$/;\n\nconst uploadPlugin = (options) =>\n  new Plugin({\n    props: {\n      handleDOMEvents: {\n        paste(view, event: ClipboardEvent): boolean {\n          if (\n            (view.props.editable && !view.props.editable(view.state)) ||\n            !options.uploadImage\n          ) {\n            return false;\n          }\n\n          if (!event.clipboardData) return false;\n\n          // check if we actually pasted any files\n          const files = Array.prototype.slice\n            .call(event.clipboardData.items)\n            .map((dt) => dt.getAsFile())\n            .filter((file) => file);\n\n          if (files.length === 0) return false;\n\n          const { tr } = view.state;\n          if (!tr.selection.empty) {\n            tr.deleteSelection();\n          }\n          const pos = tr.selection.from;\n\n          insertFiles(view, event, pos, files, options);\n          return true;\n        },\n        drop(view, event: DragEvent): boolean {\n          if (\n            (view.props.editable && !view.props.editable(view.state)) ||\n            !options.uploadImage\n          ) {\n            return false;\n          }\n\n          // filter to only include image files\n          const files = getDataTransferFiles(event).filter((file) =>\n            /image/i.test(file.type)\n          );\n          if (files.length === 0) {\n            return false;\n          }\n\n          // grab the position in the document for the cursor\n          const result = view.posAtCoords({\n            left: event.clientX,\n            top: event.clientY,\n          });\n\n          if (result) {\n            insertFiles(view, event, result.pos, files, options);\n            return true;\n          }\n\n          return false;\n        },\n      },\n    },\n  });\n\nconst IMAGE_CLASSES = [\"right-50\", \"left-50\"];\nconst getLayoutAndTitle = (tokenTitle) => {\n  if (!tokenTitle) return {};\n  if (IMAGE_CLASSES.includes(tokenTitle)) {\n    return {\n      layoutClass: tokenTitle,\n    };\n  } else {\n    return {\n      title: tokenTitle,\n    };\n  }\n};\n\nconst downloadImageNode = async (node) => {\n  const image = await fetch(node.attrs.src);\n  const imageBlob = await image.blob();\n  const imageURL = URL.createObjectURL(imageBlob);\n  const extension = imageBlob.type.split(\"/\")[1];\n  const potentialName = node.attrs.alt || \"image\";\n\n  // create a temporary link node and click it with our image data\n  const link = document.createElement(\"a\");\n  link.href = imageURL;\n  link.download = `${potentialName}.${extension}`;\n  document.body.appendChild(link);\n  link.click();\n\n  // cleanup\n  document.body.removeChild(link);\n};\n\nexport default class Image extends Node {\n  get name() {\n    return \"image\";\n  }\n\n  get schema() {\n    return {\n      inline: true,\n      attrs: {\n        src: {},\n        alt: {\n          default: null,\n        },\n        layoutClass: {\n          default: null,\n        },\n        title: {\n          default: null,\n        },\n      },\n      content: \"text*\",\n      marks: \"\",\n      group: \"inline\",\n      selectable: true,\n      draggable: true,\n      parseDOM: [\n        {\n          tag: \"div[class~=image]\",\n          getAttrs: (dom: HTMLDivElement) => {\n            const img = dom.getElementsByTagName(\"img\")[0];\n            const className = dom.className;\n            const layoutClassMatched =\n              className && className.match(/image-(.*)$/);\n            const layoutClass = layoutClassMatched\n              ? layoutClassMatched[1]\n              : null;\n            return {\n              src: img?.getAttribute(\"src\"),\n              alt: img?.getAttribute(\"alt\"),\n              title: img?.getAttribute(\"title\"),\n              layoutClass: layoutClass,\n            };\n          },\n        },\n        {\n          tag: \"img\",\n          getAttrs: (dom: HTMLImageElement) => {\n            return {\n              src: dom.getAttribute(\"src\"),\n              alt: dom.getAttribute(\"alt\"),\n              title: dom.getAttribute(\"title\"),\n            };\n          },\n        },\n      ],\n      toDOM: (node) => {\n        const className = node.attrs.layoutClass\n          ? `image image-${node.attrs.layoutClass}`\n          : \"image\";\n        return [\n          \"div\",\n          {\n            class: className,\n          },\n          [\"img\", { ...node.attrs, contentEditable: false }],\n          [\"p\", { class: \"caption\" }, 0],\n        ];\n      },\n    };\n  }\n\n  handleKeyDown =\n    ({ node, getPos }) =>\n    (event) => {\n      // Pressing Enter in the caption field should move the cursor/selection\n      // below the image\n      if (event.key === \"Enter\") {\n        event.preventDefault();\n\n        const { view } = this.editor;\n        const $pos = view.state.doc.resolve(getPos() + node.nodeSize);\n        view.dispatch(\n          view.state.tr.setSelection(new TextSelection($pos)).split($pos.pos)\n        );\n        view.focus();\n        return;\n      }\n\n      // Pressing Backspace in an an empty caption field should remove the entire\n      // image, leaving an empty paragraph\n      if (event.key === \"Backspace\" && event.target.innerText === \"\") {\n        const { view } = this.editor;\n        const $pos = view.state.doc.resolve(getPos());\n        const tr = view.state.tr.setSelection(new NodeSelection($pos));\n        view.dispatch(tr.deleteSelection());\n        view.focus();\n        return;\n      }\n    };\n\n  handleBlur =\n    ({ node, getPos }) =>\n    (event) => {\n      const alt = event.target.innerText;\n      const { src, title, layoutClass } = node.attrs;\n\n      if (alt === node.attrs.alt) return;\n\n      const { view } = this.editor;\n      const { tr } = view.state;\n\n      // update meta on object\n      const pos = getPos();\n      const transaction = tr.setNodeMarkup(pos, undefined, {\n        src,\n        alt,\n        title,\n        layoutClass,\n      });\n      view.dispatch(transaction);\n    };\n\n  handleSelect =\n    ({ getPos }) =>\n    (event) => {\n      event.preventDefault();\n\n      const { view } = this.editor;\n      const $pos = view.state.doc.resolve(getPos());\n      const transaction = view.state.tr.setSelection(new NodeSelection($pos));\n      view.dispatch(transaction);\n    };\n\n  handleDownload =\n    ({ node }) =>\n    (event) => {\n      event.preventDefault();\n      event.stopPropagation();\n      downloadImageNode(node);\n    };\n\n  component = (props) => {\n    const { theme, isSelected } = props;\n    const { alt, src, title, layoutClass } = props.node.attrs;\n    const className = layoutClass ? `image image-${layoutClass}` : \"image\";\n\n    return (\n      <div contentEditable={false} className={className}>\n        <ImageWrapper\n          className={isSelected ? \"ProseMirror-selectednode\" : \"\"}\n          onClick={this.handleSelect(props)}\n        >\n          <Button>\n            <DownloadIcon\n              color=\"currentColor\"\n              onClick={this.handleDownload(props)}\n            />\n          </Button>\n          <ImageZoom\n            image={{\n              src,\n              alt,\n              title,\n            }}\n            defaultStyles={{\n              overlay: {\n                backgroundColor: theme.background,\n              },\n            }}\n            shouldRespectMaxDimension\n          />\n        </ImageWrapper>\n        <Caption\n          onKeyDown={this.handleKeyDown(props)}\n          onBlur={this.handleBlur(props)}\n          className=\"caption\"\n          tabIndex={-1}\n          role=\"textbox\"\n          contentEditable\n          suppressContentEditableWarning\n          data-caption={this.options.dictionary.imageCaptionPlaceholder}\n        >\n          {alt}\n        </Caption>\n      </div>\n    );\n  };\n\n  toMarkdown(state, node) {\n    let markdown =\n      \" ![\" +\n      state.esc((node.attrs.alt || \"\").replace(\"\\n\", \"\") || \"\") +\n      \"](\" +\n      state.esc(node.attrs.src);\n    if (node.attrs.layoutClass) {\n      markdown += ' \"' + state.esc(node.attrs.layoutClass) + '\"';\n    } else if (node.attrs.title) {\n      markdown += ' \"' + state.esc(node.attrs.title) + '\"';\n    }\n    markdown += \")\";\n    state.write(markdown);\n  }\n\n  parseMarkdown() {\n    return {\n      node: \"image\",\n      getAttrs: (token) => {\n        return {\n          src: token.attrGet(\"src\"),\n          alt: (token.children[0] && token.children[0].content) || null,\n          ...getLayoutAndTitle(token.attrGet(\"title\")),\n        };\n      },\n    };\n  }\n\n  commands({ type }) {\n    return {\n      downloadImage: () => async (state) => {\n        const { node } = state.selection;\n\n        if (node.type.name !== \"image\") {\n          return false;\n        }\n\n        downloadImageNode(node);\n\n        return true;\n      },\n      deleteImage: () => (state, dispatch) => {\n        dispatch(state.tr.deleteSelection());\n        return true;\n      },\n      alignRight: () => (state, dispatch) => {\n        const attrs = {\n          ...state.selection.node.attrs,\n          title: null,\n          layoutClass: \"right-50\",\n        };\n        const { selection } = state;\n        dispatch(state.tr.setNodeMarkup(selection.from, undefined, attrs));\n        return true;\n      },\n      alignLeft: () => (state, dispatch) => {\n        const attrs = {\n          ...state.selection.node.attrs,\n          title: null,\n          layoutClass: \"left-50\",\n        };\n        const { selection } = state;\n        dispatch(state.tr.setNodeMarkup(selection.from, undefined, attrs));\n        return true;\n      },\n      replaceImage: () => (state) => {\n        const { view } = this.editor;\n        const {\n          uploadImage,\n          onImageUploadStart,\n          onImageUploadStop,\n          onShowToast,\n        } = this.editor.props;\n\n        if (!uploadImage) {\n          throw new Error(\"uploadImage prop is required to replace images\");\n        }\n\n        // create an input element and click to trigger picker\n        const inputElement = document.createElement(\"input\");\n        inputElement.type = \"file\";\n        inputElement.accept = \"image/*\";\n        inputElement.onchange = (event: Event) => {\n          const files = getDataTransferFiles(event);\n          insertFiles(view, event, state.selection.from, files, {\n            uploadImage,\n            onImageUploadStart,\n            onImageUploadStop,\n            onShowToast,\n            dictionary: this.options.dictionary,\n            replaceExisting: true,\n          });\n        };\n        inputElement.click();\n      },\n      alignCenter: () => (state, dispatch) => {\n        const attrs = { ...state.selection.node.attrs, layoutClass: null };\n        const { selection } = state;\n        dispatch(state.tr.setNodeMarkup(selection.from, undefined, attrs));\n        return true;\n      },\n      createImage: (attrs) => (state, dispatch) => {\n        const { selection } = state;\n        const position = selection.$cursor\n          ? selection.$cursor.pos\n          : selection.$to.pos;\n        const node = type.create(attrs);\n        const transaction = state.tr.insert(position, node);\n        dispatch(transaction);\n        return true;\n      },\n    };\n  }\n\n  inputRules({ type }) {\n    return [\n      new InputRule(IMAGE_INPUT_REGEX, (state, match, start, end) => {\n        const [okay, alt, src, matchedTitle] = match;\n        const { tr } = state;\n\n        if (okay) {\n          tr.replaceWith(\n            start - 1,\n            end,\n            type.create({\n              src,\n              alt,\n              ...getLayoutAndTitle(matchedTitle),\n            })\n          );\n        }\n\n        return tr;\n      }),\n    ];\n  }\n\n  get plugins() {\n    return [uploadPlaceholderPlugin, uploadPlugin(this.options)];\n  }\n}\n\nconst Button = styled.button`\n  position: absolute;\n  top: 8px;\n  right: 8px;\n  border: 0;\n  margin: 0;\n  padding: 0;\n  border-radius: 4px;\n  background: ${(props) => props.theme.background};\n  color: ${(props) => props.theme.textSecondary};\n  width: 24px;\n  height: 24px;\n  display: inline-block;\n  cursor: pointer;\n  opacity: 0;\n  transition: opacity 100ms ease-in-out;\n\n  &:active {\n    transform: scale(0.98);\n  }\n\n  &:hover {\n    color: ${(props) => props.theme.text};\n    opacity: 1;\n  }\n`;\n\nconst Caption = styled.p`\n  border: 0;\n  display: block;\n  font-size: 13px;\n  font-style: italic;\n  font-weight: normal;\n  color: ${(props) => props.theme.textSecondary};\n  padding: 2px 0;\n  line-height: 16px;\n  text-align: center;\n  min-height: 1em;\n  outline: none;\n  background: none;\n  resize: none;\n  user-select: text;\n  cursor: text;\n\n  &:empty:not(:focus) {\n    visibility: hidden;\n  }\n\n  &:empty:before {\n    color: ${(props) => props.theme.placeholder};\n    content: attr(data-caption);\n    pointer-events: none;\n  }\n`;\n\nconst ImageWrapper = styled.span`\n  line-height: 0;\n  display: inline-block;\n  position: relative;\n\n  &:hover {\n    ${Button} {\n      opacity: 0.9;\n    }\n  }\n\n  &.ProseMirror-selectednode + ${Caption} {\n    visibility: visible;\n  }\n`;\n","import { Node } from \"prosemirror-model\";\nimport { EditorState } from \"prosemirror-state\";\n\nexport default function getParentListItem(\n  state: EditorState\n): [Node, number] | void {\n  const $head = state.selection.$head;\n  for (let d = $head.depth; d > 0; d--) {\n    const node = $head.node(d);\n    if ([\"list_item\", \"checkbox_item\"].includes(node.type.name)) {\n      return [node, $head.before(d)];\n    }\n  }\n}\n"],"names":[],"sourceRoot":""}